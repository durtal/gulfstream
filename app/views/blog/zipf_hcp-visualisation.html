<div class="col-sm-12">
	<h2>Intro</h2>
	<p>This post walks through the method of race standardisation used in creating the ratings found in this app, and is included in my <a href="https://github.com/durtal/RcappeR" target="_blank">RcappeR</a> package as a family of three functions, <code>zipf_race</code>, <code>zipf_hcp</code>, and <code>zipf_init</code>.  It was first explained by Simon Rowlands, of <a href="https://www.timeform.com/racing/">Timeform</a>, find his article <a href="https://betting.betfair.com/horse-racing/bloggers/simon-rowlands/simon-rowlands-on-handicapping-060710.html" target="_blank">here</a>, there is an summary explanation in this post, as well as a look at the specific functions included in <strong>RcappeR</strong>, also included is an interactive visualisation, using <a href="https://angularjs.org/">AngularJS</a> and <a href="http://d3js.org/">D3</a>, which shows what two of these functions do.</p>

	<h2>Race Standardisation (<code>zipf_race</code>)</h2>
	<p>Simon remarks that <em>"races and race types repeat the same sort of level of form, year in, year out"</em>, which is the premise for race standardisation.  It uses past runnings of a race, eg The Kentucky Derby, or the Epsom Derby, to assess a recent renewal of the race.  There are different methods of race standardisation but the example Simon walks through, and the one that is used in RcappeR, uses Zipf's Law.</p>

	<div class="row">
		<div class="col-sm-8">
			<p>For simplicity sake I'll walk through the same example found in Simon's piece, readers should still read that piece as it addresses some important issues and touches on some applications for race standardisation.</p>

			<p>In the example there are three, fictional, past races, where runners' performances have been assessed and awarded ratings, these can be seen in the table to the right, under the heading <strong>Past Ratings</strong>.  The table contains ratings for the first 5 runners, these ratings are used to handicap a new race.</p>

			<p>The new race, that requires handicapping, needs to be prepared, Simon doesn't touch on this in the article, but we will quickly cover it here.  Essentially the preparation requires the winners performance to be assessed against the runners it has just beaten.  This means establishing, typically in lbs, the margin of superiority between itself and runners up.  Timeform call this 'difference at the weights', which takes into account, going, distance, margins, weight carried, among a few other important factors.</p>
		</div>
		<div class="col-sm-4">
			<h4>Past Ratings</h4>
			<table class="table table-condensed">
				<thead>
					<tr>
						<td>Race</td>
						<td>1st</td>
						<td>2nd</td>
						<td>3rd</td>
						<td>4th</td>
						<td>5th</td>
					</tr>
				</thead>
				<tbody>
					<tr ng-repeat="pastrace in ExampleRaces">
						<td>{{ pastrace.year }}</td>
						<td>{{ pastrace.p1 }}</td>
						<td>{{ pastrace.p2 }}</td>
						<td>{{ pastrace.p3 }}</td>
						<td>{{ pastrace.p4 }}</td>
						<td>{{ pastrace.p5 }}</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div class="col-sm-12">
			<p><strong>RcappeR</strong> provides functionality to produce something similar to difference at the weights, but it is not as complex or as extensive in the number of factors it can take into account.  An example of this preparation can be seen in a number of blog posts on this site, <a href="http://durtal.github.io/gulfstream/#/blog/31-1-15">see here</a>, or in the <a href="http://durtal.github.io/RcappeR/data_prep.html">Data Preparation</a> vignette included in the package.  It results in something similar to that shown in <strong>New Race</strong>, and can be read as follows, the winner is rated 5lbs > 2nd, 10lbs > 3rd, 15lbs > 4th and 20lbs > 5th.</p>

			<p>The margins, from the new race, between the winner and its beaten rivals are added, according to finishing position, to the ratings from past races, resulting in a vector of ratings for the winner.  For example, using the ratings from 2011, the winner of the new race would be rated 102 by the winner, rated 95 by the second placed horse from 2011 (90 + 5), 90 by the third placed horse (80 + 10), 90 (75 + 15) by the fourth placed horse, and 93 by the fifth placed horse (73 + 20).  These new ratings can be seen in the table <strong>Winners Rating by Position</strong>.</p>

			<p>These ratings are then weighted inversely according to rank, taking 2011, the rating of 102, using the winner, would be multiplied by 1; the rating of 95, using the 2nd horse, multiplied by 1/2; the rating of 90 multiplied by 1/3; 90 multiplied by 1/4; 93 multiplied by 1/5.  This results in the table <strong>New Weighted Ratings</strong>.</p>
		</div>
		<div class="col-sm-4">
			<h4>New Race</h4>
			<table class="table table-condensed">
				<thead>
					<tr>
						<td>Race</td>
						<td>1st</td>
						<td>2nd</td>
						<td>3rd</td>
						<td>4th</td>
						<td>5th</td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>{{ race.year }}</td>
						<td>{{ race.p1 }}</td>
						<td>{{ race.p2 }}</td>
						<td>{{ race.p3 }}</td>
						<td>{{ race.p4 }}</td>
						<td>{{ race.p5 }}</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div class="col-sm-4">
			<h4>Winners Rating by Position</h4>
			<table class="table table-condensed">
				<thead>
					<tr>
						<td>Race</td>
						<td>1st</td>
						<td>2nd</td>
						<td>3rd</td>
						<td>4th</td>
						<td>5th</td>
					</tr>
				</thead>
				<tbody>
					<tr ng-repeat="pastrace in ExampleRaces">
						<td>{{ pastrace.year }}</td>
						<td>{{ pastrace.p1 + race.p1 }}</td>
						<td>{{ pastrace.p2 + race.p2 }}</td>
						<td>{{ pastrace.p3 + race.p3 }}</td>
						<td>{{ pastrace.p4 + race.p4 }}</td>
						<td>{{ pastrace.p5 + race.p5 }}</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div class="col-sm-4">
			<h4>New Weighted Ratings</h4>
			<table class="table table-condensed">
				<thead>
					<tr>
						<td>Race</td>
						<td>1st</td>
						<td>2nd</td>
						<td>3rd</td>
						<td>4th</td>
						<td>5th</td>
					</tr>
				</thead>
				<tbody>
					<tr ng-repeat="pastrace in weightedRatings">
						<td>{{ pastrace.year }}</td>
						<td>{{ pastrace.p1 * 1 | number: 1 }}</td>
						<td>{{ pastrace.p2 * 1/2 | number: 1 }}</td>
						<td>{{ pastrace.p3 * 1/3 | number: 1 }}</td>
						<td>{{ pastrace.p4 * 1/2 | number: 1 }}</td>
						<td>{{ pastrace.p5 * 1/5 | number: 1 }}</td>
					</tr>
				</tbody>
			</table>
		</div>
	</div>
		<p>These new weighted ratings are then summed together and divided by the sum of the weights (1 + 1/2 + 1/3 + 1/4 + 1/5), resulting in a rating for the winner of the new race using the margins in its race and ratings of past races.</p>

		<table class="table table-condensed">
			<thead>
				<tr>
					<td>Year</td>
					<td>1st</td>
					<td></td>
					<td>2nd</td>
					<td></td>
					<td>3rd</td>
					<td></td>
					<td>4th</td>
					<td></td>
					<td>5th</td>
					<td></td>
					<td>Total</td>
					<td></td>
					<td>Weights</td>
					<td></td>
					<td>Rating</td>
				</tr>
			</thead>
			<tbody>
				<tr ng-repeat="rating in weightedRatings">
					<td>{{ rating.year }}</td>
					<td>{{ rating.p1 * 1/1 | number: 2 }}</td>
					<td><strong>+</strong></td>
					<td>{{ rating.p2 * 1/2 | number: 2 }}</td>
					<td><strong>+</strong></td>
					<td>{{ rating.p3 * 1/3 | number: 2 }}</td>
					<td><strong>+</strong></td>
					<td>{{ rating.p4 * 1/4 | number: 2 }}</td>
					<td><strong>+</strong></td>
					<td>{{ rating.p5 * 1/5 | number: 2 }}</td>
					<td><strong>=</strong></td>
					<td>{{ (rating.p1 * 1) + (rating.p2 * 1/2) + (rating.p3 * 1/3) + (rating.p4 * 1/4) + (rating.p5 * 1/5) | number: 2 }}</td>
					<td><strong>/</strong></td>
					<td>{{ 1 + 1/2 + 1/3 + 1/4 + 1/5 | number: 2 }}</td>
					<td><strong>=</strong></td>
					<td><strong>{{ ((rating.p1 * 1) + (rating.p2 * 1/2) + (rating.p3 * 1/3) + (rating.p4 * 1/4) + (rating.p5 * 1/5))  / (1 + 1/2 + 1/3 + 1/4 + 1/5) | number: 2 }}</strong></td>
				</tr>
			</tbody>
		</table>
		<p>The calculation above is what the <code>zipf_race</code> function performs for RcappeR.  It takes two dataframes of two different races, one of which has previously been rated/assessed.  It uses the difference at the weights from one race, applies it to a second race for which ratings exist, returning a single value.</p>

	<h2><code>zipf_hcp</code></h2>
	<p><code>zipf_hcp</code> uses <code>zipf_race</code>, and instead of a one to one assessment, there is a one to many assesment.  So <code>zipf_race</code> would be called for one race, for example the 2009 race above, while <code>zipf_hcp</code> could be used on a dataframe containing all 3 races, 2009 thru 2011, races are iterated through, each one returning a single rating for the winner of a new race.  These ratings then build up a distribution of possible ratings.  To read more about <code>zipf_hcp</code> there is a designated vignette included in the package, find it <a href="http://durtal.github.io/RcappeR/handicap_with_zipf_hcp.html">here</a>.</p>


</div>
